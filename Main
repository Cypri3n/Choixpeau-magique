'''
LE CHOIXPEAU MAGIQUE


REGLES:




BONUS:
Le jeu possède également une interface graphique 




AUTEURS:
Cyprien Venard
Martin Ray
Ewen Legrand


LICENCE:
Aucune


VERSION:
0.1


DATE DE DERNIERE REVISION:
08/01/2024


ADRESSE GITHUB: 
https://github.com/Cypri3n/Choixpeau-magique/main

'''

# coding: utf-8

#import des modules
import csv
from math import sqrt


#Données
with open("U:\Documents\A mini projet\Caracteristiques_des_persos (1).csv", mode='r', encoding='utf-8') as f:
  reader = csv.DictReader(f,delimiter=';')
  caracteristiques_tab = [{key : value for key, value in element.items()} for element in reader]
with open("U:\Documents\A mini projet\Characters.csv", mode='r', encoding='utf-8') as f:
    reader = csv.DictReader(f, delimiter=';')
    characters_tab = [{key : value.replace('\xa0', ' ') for key, value in element.items()} for element in reader]
    

# Fusion des tables
house_tab = []
for kaggle_character in characters_tab:
    for poudlard_character in caracteristiques_tab:
        if kaggle_character['Name'] == poudlard_character['Name']:
            kaggle_character.update(poudlard_character)
            house_tab.append(kaggle_character)  

print(house_tab)

profil = {'Courage': 1, 'Ambition': 2, 'Intelligence': 5, 'Good': 3}

# Distance 

def distance(perso_cible, voisin):
    return sqrt((int(voisin['Courage']) - int(perso_cible['Courage']))**2 + 
    (int(voisin['Ambition']) - int(perso_cible['Ambition']))**2 + \
    (int(voisin['Intelligence']) - int(perso_cible['Intelligence']))**2 + 
    (int(voisin['Good']) - int(perso_cible['Good'])**2))

def ajout_distances(tab, joueur_inconnu):
    for joueur in tab:
        joueur['Distance'] = distance(joueur_inconnu, joueur)
    return tab

calimero = {'Courage': 1, 'Ambition': 2, 'Intelligence': 5, 'Good': 3}

 
house_tab = ajout_distances(house_tab, calimero)

print(house_tab)








'''
# Prédiction de la maison du profile cible
def predict_house(perso_cible, voisin, k):

  #calcul distances
  distances = distance(perso_cible, voisin)
  sorted_neighbors = sorted(distances.items(), key=lambda x: x[1])[:k] 

  # Extract houses of the k nearest neighbors
  neighbor_houses = [house for profile, house in sorted_neighbors]
  # Prédit la maison en fonction des maisons les plus communes de kkpv
  predicted_house = max(set(neighbor_houses), key=neighbor_houses.count)
  
  return predicted_house




# Vérification croisée

def verification_croisee(max_k):
    dico_reussite = {k: 0 for k in range(max_k)}  # Use a dictionary comprehension to initialize dico_reussites

    for k in range(max_k):
        for personnage in characters_list:
            if predict_house(personnage, k) == house_tab[personnage]['House']:
                dico_reussite[k] += 1

    max = 0
    for value in dico_reussite:
        if dico_reussite[value] > max:
            max = dico_reussite[value]
    return max
 '''  
