'''
LE CHOIXPEAU MAGIQUE


REGLES:




BONUS:
Le jeu possède également une interface graphique 




AUTEURS:
Cyprien Venard
Martin Ray
Ewen Legrand


LICENCE:
Aucune


VERSION:
0.1


DATE DE DERNIERE REVISION:
08/01/2024


ADRESSE GITHUB: 
https://github.com/Cypri3n/Choixpeau-magique/main

'''

# coding: utf-8

#import des modules
import csv
from random import randint
from math import sqrt

#Données
with open("U:\Documents\A mini projet\Caracteristiques_des_persos (1).csv", mode='r', encoding='utf-8') as f:
  reader = csv.DictReader(f,delimiter=';')
  caracteristiques_tab = [{key : value for key, value in element.items()} for element in reader]
with open("U:\Documents\A mini projet\Characters.csv", mode='r', encoding='utf-8') as f:
    reader = csv.DictReader(f, delimiter=';')
    characters_tab = [{key : value.replace('\xa0', ' ') for key, value in element.items()} for element in reader]
    

# Fusion des tables
house_tab = []
for kaggle_character in characters_tab:
    for poudlard_character in caracteristiques_tab:
        if kaggle_character['Name'] == poudlard_character['Name']:
            kaggle_character.update(poudlard_character)
            house_tab.append(kaggle_character)  

# Distance 

def distance(perso_cible, voisin):
    return sqrt( (int(voisin['Courage']) - int(perso_cible['Courage']))**2 + 
    (int(voisin['Ambition']) - int(perso_cible['Ambition']))**2 + 
    (int(voisin['Intelligence']) - int(perso_cible['Intelligence']))**2 + 
    (int(voisin['Good']) - int(perso_cible['Good']))**2)

def ajout_distances(tab, joueur_inconnu):
    for joueur in tab:
        joueur['Distance'] = distance(joueur_inconnu, joueur)
    return tab

def best_house(tab):
    houses = {}
    for voisin in tab:
        if voisin['House'] in houses:
            houses[voisin['House']] += 1
        else:
            houses[voisin['House']] = 1
    maximum = 0
    for house, nb in houses.items():
        if nb > maximum:
            maximum = nb
            top_house = house
    return top_house

new_students = [{'Courage': 9, 'Ambition': 2, 'Intelligence': 8, 'Good': 9},
           {'Courage': 6, 'Ambition': 7, 'Intelligence': 8, 'Good': 7},
           {'Courage': 3, 'Ambition': 8, 'Intelligence': 6, 'Good': 3},
           {'Courage': 2, 'Ambition': 3, 'Intelligence': 7, 'Good': 8},
           {'Courage': 3, 'Ambition': 4, 'Intelligence': 8, 'Good': 8}]

k = 5

# Profil par défauts
for student in new_students:
    house_tab = ajout_distances(house_tab, student)
    neighbors = sorted(house_tab, key=lambda x: x['Distance'])
    print(f"Pour un profil de {student}, on a :")
    for neighbor in neighbors[:k]:
        print(f"{neighbor['Name']}, de {neighbor['House']}, à {neighbor['Distance']} de distance,")
    print(f"et la maison est : {best_house(neighbors[:k])} !\n")

# Profil utilisateur 
student_courage = input("Quelle est votre courage: ")
student_ambition = input("Quelle est votre ambition: ")
student_intelligence = input("Quelle est votre intelligence: ")
student_good = input("Quelle est votre bien: ")
student_user = {'Courage': student_courage, 'Ambition': student_ambition, 'Intelligence': student_intelligence, 'Good': student_good}

house_tab = ajout_distances(house_tab, student_user)
neighbors = sorted(house_tab, key=lambda x: x['Distance'])
print("\nPour votre profil, on a :")
for neighbor in neighbors[:k]:
    print(f"{neighbor['Name']}, de {neighbor['House']}, à {neighbor['Distance']} de distance,")
print(f"et votre maison est : {best_house(neighbors[:k])} !\n")

# Vérification croisée

# Extraction d'un tiers des données pour test de validation  
def creation_donnees_test(tab):
    joueurs_test = []
    copie_joueurs = house_tab[:]
    for _ in range(len(copie_joueurs) // 4):
        joueurs_test.append(copie_joueurs.pop(randint(0, len(copie_joueurs) - 1)))
    return joueurs_test, copie_joueurs

nb_tests = 100

for k in range(1, 31):
    bingo = 0
    for test in range(nb_tests):
        joueurs_test, joueurs_reference = creation_donnees_test(house_tab)
        for joueur_cible in joueurs_test:
            joueurs_reference = ajout_distances(joueurs_reference, joueur_cible)
            other_voisins = sorted(joueurs_reference, key=lambda x: x['Distance'])
            if best_house(other_voisins[:k]) == joueur_cible['House']:
                bingo += 1
    print(f"Pourcentage de réussite avec k = {k} : {round(bingo / len(joueurs_test))}")
