'''
LE CHOIXPEAU MAGIQUE


REGLES:




BONUS:
Le jeu possède également une interface graphique 




AUTEURS:
Cyprien Venard
Martin Ray
Ewen Legrand


LICENCE:
Aucune


VERSION:
0.1


DATE DE DERNIERE REVISION:
08/01/2024


ADRESSE GITHUB: 
https://github.com/Cypri3n/Choixpeau-magique/main

'''

# coding: utf-8

#import des modules
import csv
import math


#Données
with open("U:\Documents\A mini projet\Caracteristiques_des_persos (1).csv", mode='r', encoding='utf-8') as f:
  reader = csv.DictReader(f,delimiter=';')
  characteristiques_tab = [{key : value for key, value in element.items()} for element in reader]
with open("U:\Documents\A mini projet\Characters.csv", mode='r', encoding='utf-8') as f:
    reader = csv.DictReader(f, delimiter=';')
    characters_tab = [{key : value.replace('\xa0', ' ') for key, value in element.items()} for element in reader]
complete_tab = []
for name in characteristiques_tab:
    complete_tab.append(characters_tab[name]['House'])
print(complete_tab)

# Fusion des tables
house_tab = []
for line in characteristiques_tab:
  for line2 in characters_tab:
    if line['Name'] == line2['Name']:
      house_tab.append(line['House'])  




# Distance euclidienne
def distance_euclidienne(perso_cible):
  assert perso_cible in complete_tab, "Ce personnage n'est pas disponible"
  distance_dico = {}
  for name in complete_tab:
    if name != perso_cible:
      distance_dico[name] = sqrt((complete_tab[name]['Courage'] - complete_tab[perso_cible]['Courage'])**2 + \
      (complete_tab[name]['Ambition'] - complete_tab[perso_cible]['Ambition'])**2 + \
      (complete_tab[name]['Intelligence'] - complete_tab[perso_cible]['Intelligence'])**2 + \
      (complete_tab[name]['Good'] - complete_tab[perso_cible]['Good'])**2)
  return distance_dico


# Prédiction de la maison du profile cible
def predict_house(perso_cible, k):

#calcul distances
  distances = distance_euclidienne(perso_cible)
  sorted_neighbors = sorted(distances.items(), key=lambda x: x[1])[:k] 

  # Extract houses of the k nearest neighbors
  neighbor_houses = [house for profile, house in sorted_neighbors]
  # Prédit la maison en fonction des maisons les plus communes de kkpv
  predicted_house = max(set(neighbor_houses), key=neighbor_houses.count)
  
  return predicted_house


# Vérification croisée

def verification_croisee(max_k):
    dico_reussites = {k: 0 for k in range(max_k)}  # Use a dictionary comprehension to initialize dico_reussites

    for k in range(max_k):
        for personnage in characters_list:
            if predict_house(personnage, k) == house_tab[personnage]['House']:
                dico_reussites[k] += 1

    max = 0
    for value in dico_reussite:
        if dico_reussite[value] > max:
            max = dico_reussite[value]
    return max
    
