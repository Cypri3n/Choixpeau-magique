'''
LE CHOIXPEAU MAGIQUE


REGLES:




BONUS:
Le jeu possède également une interface graphique 




AUTEURS:
Cyprien Venard
Martin Ray
Ewen Legrand


LICENCE:
Aucune


VERSION:
0.1


DATE DE DERNIERE REVISION:
08/01/2024


ADRESSE GITHUB: 
https://github.com/Cypri3n/Choixpeau-magique/main

'''

# coding: utf-8

#import des modules
import csv
from random import randint
from math import sqrt

#Données
with open("Caracteristiques_des_persos.csv", mode='r', encoding='utf-8') as f:
  reader = csv.DictReader(f,delimiter=';')
  caracteristiques_tab = [{key : value for key, value in element.items()} for element in reader]
with open("Characters(1).csv", mode='r', encoding='utf-8') as f:
    reader = csv.DictReader(f, delimiter=';')
    characters_tab = [{key : value.replace('\xa0', ' ') for key, value in element.items()} for element in reader]
    

# Fusion des tables
house_tab = []
for kaggle_character in characters_tab:
    for poudlard_character in caracteristiques_tab:
        if kaggle_character['Name'] == poudlard_character['Name']:
            kaggle_character.update(poudlard_character)
            house_tab.append(kaggle_character)  

# Distance 

def distance(perso_cible, voisin):
    return sqrt((int(voisin['Courage']) - int(perso_cible['Courage']))**2 + 
    (int(voisin['Ambition']) - int(perso_cible['Ambition']))**2 + \
    (int(voisin['Intelligence']) - int(perso_cible['Intelligence']))**2 + 
    (int(voisin['Good']) - int(perso_cible['Good'])**2))

def ajout_distances(tab, joueur_inconnu):
    for joueur in tab:
        joueur['Distance'] = distance(joueur_inconnu, joueur)
    return tab

Jean = {'Courage': 1, 'Ambition': 2, 'Intelligence': 5, 'Good': 3}

 
house_tab = ajout_distances(house_tab, Jean)

k = 3

voisins = sorted(house_tab, key=lambda x: x['Distance'])

def best_house(tab):
    postes = {}
    for voisin in tab:
        if voisin['House'] in postes:
            postes[voisin['House']] += 1
        else:
            postes[voisin['House']] = 1
    print(postes)
    maximum = 0
    for house, nb in postes.items():
        if nb > maximum:
            maximum = nb
            top_house = house
    return top_house

print(best_house(voisins[:k]))

# Vérification croisée

# Extraction d'un tiers des données pour test de validation  
def creation_donnees_test(tab):
    joueurs_test = []
    copie_joueurs = house_tab[:]
    for _ in range(len(copie_joueurs) // 4):
        joueurs_test.append(copie_joueurs.pop(randint(0, len(copie_joueurs) - 1)))
    return joueurs_test, copie_joueurs

nb_tests = 100

for k in range(1, 31):
    bingo = 0
    for test in range(nb_tests):
        joueurs_test, joueurs_reference = creation_donnees_test(house_tab)
        for joueur_cible in joueurs_test:
            joueurs_reference = ajout_distances(joueurs_reference, joueur_cible)
            other_voisins = sorted(joueurs_reference, key=lambda x: x['Distance'])
            if best_house(other_voisins[:k]) == joueur_cible['House']:
                bingo += 1
    print(f"Pourcentage de réussite avec k = {k} : {round(bingo / len(joueurs_test))}")
